alias ls='ls --color=auto -h --group-directories-first'
alias grep='grep --color=auto'
alias rm='rm -vI'
alias vim='nvim'
alias sxiv='sxiv'
alias s='zathura'
alias tg='Telegram'
alias ff='fastfetch'
alias sdn='shutdown now'
alias sus='systemctl suspend'
alias sz='source ~/.zshrc'
alias sx='source ~/.dotfiles/config/x11/xsetup'
alias up='sh ~/.dotfiles/scripts/update_packages.sh'
alias upp='sh ~/.dotfiles/scripts/update_packages_paru.sh'
alias sbg='xwallpaper --zoom'
alias sbgm='xwallpaper --maximize'
alias sbcl='rlwrap sbcl' # Add history and arrows navigation
alias ssh='TERM=xterm-256color EDITOR=nvim ssh'
alias pac='sudo pacman --color=auto'
alias pacman='pacman --color=auto'
alias sbgb='xwallpaper --zoom ~/.bg'
alias cbg='xwallpaper --clear'
alias translit='python ~/.dotfiles/scripts/translit.py'
alias discord='discord'
alias pavu='pavucontrol'
alias gimp='gimp'
alias cs='cht.sh --shell'
alias t='tmux'
alias ta='tmux attach'
alias obs='obs'
alias lo='libreoffice'
alias drawio='drawio'
alias zoom='zoom'
alias vb='virtualbox'
alias xx='wl-copy'
alias rs='rsync -avzP --append-verify'
alias gats='sh ~/.local/work-scripts/get-stage-access-token.sh'

alias  u='cd ~/University && l'
alias  D='cd ~/Downloads && l'
alias  d='cd ~/Documents && l'
alias  p='cd ~/Pictures && ls'
alias  v='cd ~/Videos && ls'
alias pp='cd ~/Personal && l'
alias sc='cd ~/Pictures/Screenshots && l'
alias wp='cd ~/Pictures/Wallpapers && ls'
alias tt='cd ~/Downloads/Torrents && l'
alias lb='cd ~/.local/bin && l'

alias  cf='cd ~/.config && l'
alias cdc='cd ~/.dotfiles/config && l'
alias cdl='cd ~/.local && l'
alias cdn='cd ~/.dotfiles/config/nvim && l'
alias cdp='cd ~/.local/my-packages && l'
alias cds='cd ~/.dotfiles/scripts && l'
alias cdd='cd ~/.dotfiles && l'
alias cdz='cd ~/.dotfiles/config/zsh && l'
alias cdx='cd ~/.dotfiles/config/x11 && l'
alias  cb='cd ~/Code/bmstu && l'
alias   c='cd ~/Code && l'
alias cdw='cd ~/Work && l'
alias cdh='cd ~/.config/hypr && l'
alias cdws='cd ~/.local/work-scripts && l'
alias cac='cd ~/.cache && l'

# All editing shortcuts are for dotfiles, so run Telescope from there
function zsh_vim_edit_dotfiles {
    file=$1
    back=$(pwd)
    cd $HOME/.dotfiles && vim $file && cd $back
}
e=zsh_vim_edit_dotfiles

alias cfa='$e ~/.zsh_aliases'
alias cfn='$e ~/.config/nvim/init.lua'
alias cfs='$e ~/.config/sxhkd/sxhkdrc'
alias cff='$e ~/.config/fontconfig/fonts.conf'
alias cfx='$e ~/.xprofile'
alias cfb='$e ~/.config/bspwm/bspwmrc'
alias cfl='$e ~/.dotfiles/scripts/lemonbar.sh'
alias cfz='$e ~/.zsh_profile'
alias cft='$e ~/.config/tmux/tmux.conf'
alias cft='$e ~/.config/tmux/tmux.conf'
alias cfA='$e ~/.config/alacritty/alacritty.toml'
alias cfts='$e ~/.dotfiles/scripts/bin/tmux-sessionizer'
alias cfh='$e ~/.config/hypr/hyprland.conf'
alias cfhp='$e ~/.config/hypr/hyprpaper.conf'
alias cfw='$e ~/.config/waybar/config.jsonc'
alias cfp='$e ~/.zprofile'
alias cfk='$e ~/.config/keyd/default.conf'

alias va='source .venv/bin/activate'
alias ob='obsidian'
alias hl='hyprland'

alias sgp='ssh root@stage.pro-rabota.com -C "cd /home/sql-query-portal && git pull"'
alias sbfree='sh ~/.local/work-scripts/free-sb-stage.sh'
alias cid='sh ~/.local/work-scripts/get-cid.sh'
alias first="awk '{print \$1}'"

# git worktree: interactive project/mode/branch selection via fzf, creates worktree and cds into it
function gwtx() {
    local -a fzf_base=(fzf --height=40% --layout=reverse --border)

    # Step 1: Project
    local project
    project=$(printf "backend\nfrontend" | "${fzf_base[@]}" --prompt="Project > ")
    [[ -z "$project" ]] && { echo "Cancelled."; return 0 }

    local bare_dir work_dir
    if [[ "$project" == "backend" ]]; then
        bare_dir="$HOME/Work/bare"
        work_dir="$HOME/Work"
    else
        bare_dir="$HOME/Work/frontend/bare"
        work_dir="$HOME/Work/frontend"
    fi

    if [[ ! -d "$bare_dir" ]]; then
        echo "Error: bare repo not found at $bare_dir"
        return 1
    fi

    # Step 2: Mode
    local mode
    mode=$(printf "existing branch\nsuffix to existing\nnew branch" | "${fzf_base[@]}" --prompt="[$project] Mode > ")
    [[ -z "$mode" ]] && { echo "Cancelled."; return 0 }

    # Helper: pick branch (strips *, +, spaces; deduplicates; shows commit preview)
    _gwtx_pick_branch() {
        git -C "$bare_dir" branch -a \
            | sed 's|^[*+ ]*||; s|^remotes/origin/||' \
            | grep -v '^HEAD' \
            | sort -u \
            | fzf --height=50% --layout=reverse --border \
                --prompt="$1" \
                --preview="git -C $bare_dir log --oneline --color=always --decorate {} 2>/dev/null | head -20" \
                --preview-window=right:60%
    }

    # Helper: pick local branch, already-in-worktree branches (+ prefix) sorted first
    _gwtx_pick_existing_branch() {
        {
            git -C "$bare_dir" branch | grep '^+ ' | sed 's|^+ ||'
            git -C "$bare_dir" branch | grep -v '^+ ' | sed 's|^[* ]*||'
        } | awk '!seen[$0]++' \
          | fzf --height=50% --layout=reverse --border \
                --prompt="$1" \
                --preview="git -C $bare_dir log --oneline --color=always --decorate {} 2>/dev/null | head -20" \
                --preview-window=right:60%
    }

    local new_branch worktree_path

    if [[ "$mode" == "new branch" ]]; then
        # Step 3: Type
        local type
        type=$(printf "feat\nfix\nhotfix\nrefactor\nchore\ndocs" | "${fzf_base[@]}" --prompt="[$project] Type > ")
        [[ -z "$type" ]] && { echo "Cancelled."; return 0 }

        # Step 4: Name
        echo -n "[$project] Name: "
        read -r name
        [[ -z "$name" ]] && { echo "Cancelled."; return 0 }

        # Step 5: Base branch
        local base
        base=$(_gwtx_pick_branch "[$project] Base branch > ")
        [[ -z "$base" ]] && { echo "Cancelled."; return 0 }

        new_branch="$type/$name"
        worktree_path="$work_dir/$name"

        echo ""
        echo "  Project:  $project"
        echo "  Worktree: $worktree_path"
        echo "  Branch:   $new_branch"
        echo "  Based on: $base"
        echo ""

        git -C "$bare_dir" worktree add "$worktree_path" "$base" -b "$new_branch" || return 1

    elif [[ "$mode" == "suffix to existing" ]]; then
        # Step 3: Existing branch
        local branch
        branch=$(_gwtx_pick_branch "[$project] Base branch > ")
        [[ -z "$branch" ]] && { echo "Cancelled."; return 0 }

        # Step 4: Suffix
        echo -n "[$project] Suffix (e.g. 42-add-feature): "
        read -r suffix
        [[ -z "$suffix" ]] && { echo "Cancelled."; return 0 }

        new_branch="${branch}-${suffix}"
        worktree_path="$work_dir/$suffix"

        echo ""
        echo "  Project:  $project"
        echo "  Worktree: $worktree_path"
        echo "  Branch:   $new_branch"
        echo "  Based on: $branch"
        echo ""

        git -C "$bare_dir" worktree add "$worktree_path" "$branch" -b "$new_branch" || return 1

    else
        # Step 3: Existing branch — checkout as-is, no new branch created
        local branch
        branch=$(_gwtx_pick_existing_branch "[$project] Branch > ")
        [[ -z "$branch" ]] && { echo "Cancelled."; return 0 }

        # If branch is already checked out in a worktree — just cd there
        local existing_path
        existing_path=$(git -C "$bare_dir" worktree list | grep "\[$branch\]" | awk '{print $1}')
        if [[ -n "$existing_path" ]]; then
            echo "Already checked out: $existing_path"
            cd "$existing_path"
            return 0
        fi

        # folder name: slashes → dashes
        worktree_path="$work_dir/${branch//\//-}"

        echo ""
        echo "  Project:  $project"
        echo "  Worktree: $worktree_path"
        echo "  Branch:   $branch"
        echo ""

        git -C "$bare_dir" worktree add "$worktree_path" "$branch" || return 1
    fi

    cd "$worktree_path"
}

# git worktree remove: select worktree via fzf, auto-detects project from cwd
function gwtrmx() {
    local -a fzf_base=(fzf --height=40% --layout=reverse --border)
    local cwd="$PWD"

    # Auto-detect project from current directory, otherwise ask
    local project bare_dir
    if [[ "$cwd" == "$HOME/Work/frontend"* && "$cwd" != "$HOME/Work/frontend/bare"* ]]; then
        project="frontend"
        bare_dir="$HOME/Work/frontend/bare"
    elif [[ "$cwd" == "$HOME/Work"* && "$cwd" != "$HOME/Work/bare"* && "$cwd" != "$HOME/Work/frontend"* ]]; then
        project="backend"
        bare_dir="$HOME/Work/bare"
    else
        project=$(printf "backend\nfrontend" | "${fzf_base[@]}" --prompt="Project > ")
        [[ -z "$project" ]] && { echo "Cancelled."; return 0 }
        if [[ "$project" == "backend" ]]; then
            bare_dir="$HOME/Work/bare"
        else
            bare_dir="$HOME/Work/frontend/bare"
        fi
    fi

    # Pre-fill fzf query with current worktree name if we're inside one
    local query=""
    local wt_path
    while IFS= read -r wt_path; do
        if [[ "$cwd" == "$wt_path"* ]]; then
            query=$(basename "$wt_path")
            break
        fi
    done < <(git -C "$bare_dir" worktree list | grep -v '(bare)' | awk '{print $1}')

    local selected
    selected=$(
        git -C "$bare_dir" worktree list \
            | grep -v '(bare)' \
            | "${fzf_base[@]}" \
                --prompt="[$project] Remove worktree > " \
                --query="$query" \
                --no-preview
    )
    [[ -z "$selected" ]] && { echo "Cancelled."; return 0 }

    local worktree_path
    worktree_path=$(echo "$selected" | awk '{print $1}')

    # If removing current worktree — cd out first
    if [[ "$cwd" == "$worktree_path"* ]]; then
        cd "$bare_dir"
    fi

    echo ""
    echo "  Removing: $worktree_path"
    echo ""

    git -C "$bare_dir" worktree remove "$worktree_path"
}
